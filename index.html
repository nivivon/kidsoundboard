<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Nadav's Soundboard</title>
  <style>
    :root {
      --edge-zone: 10vw;         /* left/right edge long-press trigger width */
      --press-ms: 1600;          /* long press duration */
      --gap: 14px;
      --radius: 22px;
      --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
    }

    /* Hard kill scrolling/selection */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #0b0b0f;
      font-family: var(--font);
      overscroll-behavior: none;
      touch-action: none;        /* prevents scroll/pinch in most cases */
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    /* iPhone safe areas */
    body {
      padding: env(safe-area-inset-top) env(safe-area-inset-right)
               env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    /* Layout */
    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    /* Optional tiny status (hidden by default; useful while tuning) */
    #status {
      display: none;
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      padding: 8px 12px 0;
    }

    #grid {
      flex: 1;
      display: grid;
      gap: var(--gap);
      padding: 14px;
      grid-template-columns: 1fr; /* 1x1 by default (1 tile per page) */
      grid-auto-rows: 1fr;
    }

    .tile {
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      color: white;
      font-size: clamp(42px, 8vw, 74px);
      font-weight: 800;
      background: #141420;
      border: 1px solid rgba(255,255,255,0.08);
      transform: translateZ(0);
    }

    .tile img {
      -webkit-user-drag: none;
    }

    .tile:active,
    .tile.is-playing {
      outline: 4px solid rgba(255,255,255,0.18);
      filter: brightness(1.12);
    }

    .label {
      position: absolute;
      bottom: 12px;
      left: 12px;
      right: 12px;
      font-size: 16px;
      font-weight: 700;
      opacity: 0.85;
      letter-spacing: 0.2px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .page-pill {
      position: absolute;
      top: 12px;
      right: 12px;
      font-size: 12px;
      opacity: 0.7;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.10);
      pointer-events: none;
    }

    /* Invisible edge zones for long-press */
    .edge {
      position: fixed;
      top: 0;
      bottom: 0;
      width: var(--edge-zone);
      z-index: 9999;
      background: transparent;
    }
    #edgeLeft { left: 0; }
    #edgeRight { right: 0; }

    /* Optional: show a subtle progress hint while long-pressing */
    #edgeHint {
      position: fixed;
      bottom: calc(12px + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      z-index: 10000;
      font-size: 13px;
      color: rgba(255,255,255,0.8);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px 14px;
      border-radius: 999px;
      display: none;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="status"></div>
    <div id="grid"></div>
  </div>

  <!-- invisible long-press zones -->
  <div id="edgeLeft" class="edge"></div>
  <div id="edgeRight" class="edge"></div>
  <div id="edgeHint"></div>

  <script>
    /*************************************************************
     * CONFIG: categories with gradient colors and items
     *************************************************************/
    const CATEGORIES = {
      animals: {
        gradientStart: [9, 9, 121],   // rgba(9,9,121,1)
        gradientEnd: [0, 212, 255],   // rgba(0,212,255,1)
        items: [
          { key: "bird", label: "Bird",  soundSrc: "sounds/animals/bird.mp3", imageSrc: "image/animals/bird.svg"},
          { key: "cat", label: "Cat",   soundSrc: "sounds/animals/cat.mp3", imageSrc: "image/animals/cat.svg"},
          { key: "chicken", label: "Chicken", soundSrc: "sounds/animals/chicken.mp3", imageSrc: "image/animals/chicken.svg"},
          { key: "cow", label: "Cow",   soundSrc: "sounds/animals/cow.mp3", imageSrc: "image/animals/cow.svg"},
          { key: "dinosaur", label: "Dinosaur", soundSrc: "sounds/animals/dinosaur.mp3", imageSrc: "image/animals/dinosaur.svg"},
          { key: "dog", label: "Dog",   soundSrc: "sounds/animals/dog.mp3", imageSrc: "image/animals/dog.svg"},
          { key: "duck",  label: "Duck",  soundSrc: "sounds/animals/duck.mp3", imageSrc: "image/animals/duck.svg"},
          { key: "eagle", label: "Eagle", soundSrc: "sounds/animals/eagle.mp3", imageSrc: "image/animals/eagle.svg"},
          { key: "elephant", label: "Elephant", soundSrc: "sounds/animals/elephant.mp3", imageSrc: "image/animals/elephant.svg"},
          { key: "horse", label: "Horse", soundSrc: "sounds/animals/horse.mp3", imageSrc: "image/animals/horse.svg"},
          { key: "lion",  label: "Lion",  soundSrc: "sounds/animals/lion.mp3", imageSrc: "image/animals/lion.svg"},
          { key: "monkey", label: "Monkey", soundSrc: "sounds/animals/monkey.mp3", imageSrc: "image/animals/monkey.svg"},
          { key: "mouse", label: "Mouse", soundSrc: "sounds/animals/mouse.mp3", imageSrc: "image/animals/mouse.svg"},
          { key: "owl", label: "Owl", soundSrc: "sounds/animals/owl.mp3", imageSrc: "image/animals/owl.svg"},
          { key: "pig", label: "Pig", soundSrc: "sounds/animals/pig.mp3", imageSrc: "image/animals/pig.svg"},
          { key: "rooster", label: "Rooster", soundSrc: "sounds/animals/rooster.mp3", imageSrc: "image/animals/rooster.svg"},
          { key: "sheep", label: "Sheep", soundSrc: "sounds/animals/sheep.mp3", imageSrc: "image/animals/sheep.svg"},
          { key: "snake", label: "Snake", soundSrc: "sounds/animals/snake.mp3", imageSrc: "image/animals/snake.svg"},
          { key: "tiger", label: "Tiger", soundSrc: "sounds/animals/tiger.mp3", imageSrc: "image/animals/tiger.svg"},
          { key: "wolf",  label: "Wolf",  soundSrc: "sounds/animals/wolf.mp3", imageSrc: "image/animals/wolf.svg"},
        ]
      }
      // Future categories can be added here:
      // vehicles: { gradientStart: [...], gradientEnd: [...], items: [...] },
      // instruments: { gradientStart: [...], gradientEnd: [...], items: [...] },
    };

    // Current active category
    let currentCategoryKey = "animals";
    function getCurrentCategory() {
      return CATEGORIES[currentCategoryKey];
    }
    function getCurrentItems() {
      return getCurrentCategory().items;
    }

    const TILES_PER_PAGE = 1; // 1x1
    const LONG_PRESS_MS = 800;
    const MOVE_CANCEL_PX = 12;

    /*************************************************************
     * Audio preload & play
     *************************************************************/
    const audioMap = new Map();
    let audioUnlocked = false;

    function preloadAll() {
      const items = getCurrentItems();
      for (const a of items) {
        const el = new Audio(a.soundSrc);
        el.preload = "auto";
        el.load();
        audioMap.set(a.key, el);
      }
    }

    async function unlockAudio() {
      // iOS requires a user gesture before audio can play.
      if (audioUnlocked) return;
      try {
        // play a silent-ish "prime": set volume 0 and play/pause quickly
        const items = getCurrentItems();
        const first = audioMap.get(items[0].key);
        if (!first) return;
        const prevVol = first.volume;
        first.volume = 0;
        await first.play();
        first.pause();
        first.currentTime = 0;
        first.volume = prevVol;
        audioUnlocked = true;
      } catch (e) {
        // If it fails, we'll retry on next user gesture.
      }
    }

    function playAnimal(key, tileEl) {
      const el = audioMap.get(key);
      if (!el) return;

      // Restart sound immediately
      try {
        el.pause();
        el.currentTime = 0;
      } catch {}

      // Visual feedback
      if (tileEl) {
        tileEl.classList.add("is-playing");
        setTimeout(() => tileEl.classList.remove("is-playing"), 120);
      }

      el.play().catch(() => {
        // If iOS blocks it, user needs to tap once more (unlockAudio).
      });
    }

    /*************************************************************
     * Paging + Rendering
     *************************************************************/
    let pageIndex = 0;

    function pageCount() {
      const items = getCurrentItems();
      return Math.max(1, Math.ceil(items.length / TILES_PER_PAGE));
    }

    function pageSlice(i) {
      const items = getCurrentItems();
      const start = i * TILES_PER_PAGE;
      return items.slice(start, start + TILES_PER_PAGE);
    }

    const grid = document.getElementById("grid");

    function render() {
      grid.innerHTML = "";
      const items = pageSlice(pageIndex);
      const category = getCurrentCategory();
      const pill = document.createElement("div");
      pill.className = "page-pill";
      pill.textContent = `${pageIndex + 1}/${pageCount()}`;
      grid.appendChild(pill);

      // Helper function to interpolate between two colors
      function interpolateColor(color1, color2, progress) {
        const r1 = color1[0], g1 = color1[1], b1 = color1[2];
        const r2 = color2[0], g2 = color2[1], b2 = color2[2];
        const r = Math.round(r1 + (r2 - r1) * progress);
        const g = Math.round(g1 + (g2 - g1) * progress);
        const b = Math.round(b1 + (b2 - b1) * progress);
        return `rgb(${r}, ${g}, ${b})`;
      }

      items.forEach(a => {
        // Find the index of this item in the current category's items
        const fullIndex = category.items.findIndex(item => item.key === a.key);
        const progress = category.items.length > 1 ? fullIndex / (category.items.length - 1) : 0;
        
        // Interpolate between start and end colors
        const bgColor = interpolateColor(category.gradientStart, category.gradientEnd, progress);

        const tile = document.createElement("div");
        tile.className = "tile";
        tile.dataset.key = a.key;
        tile.style.background = bgColor;

        tile.innerHTML = `
          <img src="${a.imageSrc}" alt="${a.label}" draggable="false" aria-hidden="true" style="max-width: 180px; max-height: 180px; object-fit: contain;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
          <div aria-hidden="true" style="display: none;">${a.emoji}</div>
          <div class="label">
            <span>${a.label}</span>
          </div>
        `;
        grid.appendChild(tile);
      });
    }

    function nextPage() {
      pageIndex = (pageIndex + 1) % pageCount();
      render();
    }

    function prevPage() {
      pageIndex = (pageIndex - 1 + pageCount()) % pageCount();
      render();
    }

    /*************************************************************
     * Gesture handling:
     * - Tap: play sound once
     * - Long press: loop sound continuously until release
     * - Slide: treated as tap (play once, no continuous playback)
     * - Long press edges: prev/next page
     *************************************************************/
    let activePointerId = null;
    let activeTile = null;
    let activeKey = null;
    let longPressTimer = null;
    let loopInterval = null;
    let startX = 0;
    let startY = 0;

    const LONG_PRESS_TILE_MS = 500; // Long press duration before looping starts
    const LOOP_INTERVAL_MS = 100; // Fallback interval if duration not available
    const MOVE_THRESHOLD_PX = 15; // Movement threshold to cancel long press

    function tileFromPoint(x, y) {
      const el = document.elementFromPoint(x, y);
      if (!el) return null;
      return el.closest?.(".tile") ?? null;
    }

    function clearActiveGesture() {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      if (loopInterval) {
        clearTimeout(loopInterval); // Changed from clearInterval since we're using setTimeout
        loopInterval = null;
      }
      activePointerId = null;
      activeTile = null;
      activeKey = null;
    }

    // Use pointer events for simpler cross-device behavior
    document.addEventListener("pointerdown", async (e) => {
      // Only track first pointer (kid chaos safe)
      if (activePointerId !== null) return;
      
      // Ignore edge zones (they handle their own gestures)
      if (e.target.closest?.(".edge")) return;

      activePointerId = e.pointerId;
      startX = e.clientX;
      startY = e.clientY;

      await unlockAudio();

      // Find the tile at the start point
      const tile = tileFromPoint(e.clientX, e.clientY);
      if (!tile) {
        clearActiveGesture();
        return;
      }

      activeTile = tile;
      activeKey = tile.dataset.key;

      // Play sound immediately on tap/down
      if (activeKey) {
        playAnimal(activeKey, tile);
      }

      // Set up long press timer to start looping the sound
      longPressTimer = setTimeout(() => {
        if (activeKey && activeTile) {
          // Get the audio element to determine its duration
          const audioEl = audioMap.get(activeKey);
          let loopDelay = LOOP_INTERVAL_MS;
          
          if (audioEl && !isNaN(audioEl.duration) && isFinite(audioEl.duration)) {
            // Use the actual sound duration (convert to ms, add small buffer)
            loopDelay = (audioEl.duration * 1000) + 50; // 50ms buffer for smooth looping
          }
          
          // Start looping the sound based on its duration
          function scheduleNextLoop() {
            if (activeKey && activeTile) {
              playAnimal(activeKey, activeTile);
              // Schedule next loop based on duration
              const audioEl = audioMap.get(activeKey);
              let nextDelay = LOOP_INTERVAL_MS;
              if (audioEl && !isNaN(audioEl.duration) && isFinite(audioEl.duration)) {
                nextDelay = (audioEl.duration * 1000) + 50;
              }
              loopInterval = setTimeout(scheduleNextLoop, nextDelay);
            }
          }
          
          scheduleNextLoop();
        }
      }, LONG_PRESS_TILE_MS);

      e.preventDefault();
    }, { passive: false });

    document.addEventListener("pointermove", (e) => {
      if (e.pointerId !== activePointerId) return;
      
      // Ignore sliding - don't cancel long press or loop
      // Just prevent default to avoid any browser gestures
      e.preventDefault();
    }, { passive: false });

    document.addEventListener("pointerup", (e) => {
      if (e.pointerId !== activePointerId) return;
      clearActiveGesture();
      e.preventDefault();
    }, { passive: false });

    document.addEventListener("pointercancel", (e) => {
      if (e.pointerId !== activePointerId) return;
      clearActiveGesture();
    });

    // Disable double-tap zoom on iOS
    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });

    /*************************************************************
     * Edge long press: previous/next page
     *************************************************************/
    const edgeHint = document.getElementById("edgeHint");

    function setupEdgeLongPress(edgeEl, onTrigger, label) {
      let timer = null;
      let startX = 0;
      let startY = 0;
      let pointerId = null;

      function clear() {
        if (timer) clearTimeout(timer);
        timer = null;
        pointerId = null;
        edgeHint.style.display = "none";
      }

      edgeEl.addEventListener("pointerdown", (e) => {
        // ignore if already tracking a main pointer; edges should still work, but keep simple:
        // only allow when no active pointer (reduces accidental overlap while sliding)
        if (activePointerId !== null) return;

        pointerId = e.pointerId;
        startX = e.clientX;
        startY = e.clientY;

        edgeHint.textContent = label;
        edgeHint.style.display = "block";

        timer = setTimeout(() => {
          clear();
          onTrigger();
          // Optional vibration feedback (works on some devices)
          if (navigator.vibrate) navigator.vibrate(30);
        }, LONG_PRESS_MS);

        e.preventDefault();
      }, { passive: false });

      edgeEl.addEventListener("pointermove", (e) => {
        if (e.pointerId !== pointerId) return;
        const dx = Math.abs(e.clientX - startX);
        const dy = Math.abs(e.clientY - startY);
        if (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX) clear();
        e.preventDefault();
      }, { passive: false });

      edgeEl.addEventListener("pointerup", (e) => {
        if (e.pointerId !== pointerId) return;
        clear();
        e.preventDefault();
      }, { passive: false });

      edgeEl.addEventListener("pointercancel", clear);
      edgeEl.addEventListener("pointerleave", clear);
    }

    setupEdgeLongPress(document.getElementById("edgeLeft"), prevPage, "◀︎ hold… previous");
    setupEdgeLongPress(document.getElementById("edgeRight"), nextPage, "hold… next ▶︎");

    /*************************************************************
     * Boot
     *************************************************************/
    preloadAll();
    render();
  </script>
</body>
</html>
